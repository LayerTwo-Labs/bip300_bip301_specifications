BIP-300 Protocol Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to be
interpreted as described in RFC 2119.

TODO: Reconsider the format.
TODO: Edit the specification to be in uniform style.

# Constants

```
WITHDRAWAL_BUNDLE_MAX_AGE = 26_300
WITHDRAWAL_BUNDLE_INCLUSION_THRESHOLD = WITHDRAWAL_BUNDLE_MAX_AGE / 2 = 13_150

USED_SIDECHAIN_SLOT_PROPOSAL_MAX_AGE = WITHDRAWAL_BUNDLE_MAX_AGE = 26_300
USED_SIDECHAIN_SLOT_ACTIVATION_THRESHOLD = WITHDRAWAL_BUNDLE_INCLUSION_THRESHOLD = 13_150

UNUSED_SIDECHAIN_SLOT_PROPOSAL_MAX_AGE = 2016
UNUSED_SIDECHAIN_SLOT_ACTIVATION_MAX_FAILS = 201
UNUSED_SIDECHAIN_SLOT_ACTIVATION_THRESHOLD = UNUSED_SIDECHAIN_SLOT_PROPOSAL_MAX_AGE - UNUSED_SIDECHAIN_SLOT_ACTIVATION_MAX_FAILS = 1815
```

# Message headers
```
M1: [0xD5, 0xE0, 0xC4, 0xAF]
M2: [0xD6, 0xE1, 0xC5, 0xBF]
M3: [0xD4, 0x5A, 0xA9, 0x43]
M4: [0xD7, 0x7D, 0x17, 0x76]
```

# M1. "Propose New Sidechain"

## Semantics

An M1 with sidechain slot number `S` and sidechain description `D` means:

I, someone who can include a message in the coinbase transaction of a valid
Bitcoin block, propose that a sidechain described by an array of bytes `D` be
activated in the sidechain slot defined by an unsigned integer `S`.

If the sidechain slot is `unused`, then I propose for it to be activated and
become `used` by the sidechain described by `D`.

After a sidechain slot is activated and so is `used`, it will be possible to
make deposit to and withdrawals from the sidechain described by `D`.

If the sidechain slot is `used`, then I propose for the sidechain it is
currently `used` by to be overwritten by a new sidechain described by `D`.

After the old sidechain is overwritten, it will no longer be officially
possible, as far as the BIP300 protocol is concerned, to make deposits to and
to make withdrawals from the old sidechain, the old sidechain software may do
whatever it wants in this new unofficial condition.

After the new sidechain overwrites the old one, it will be possible to make
deposits to and withdrawals from the new sidechain described by `D`.

The voting thresholds for overwriting a sidechain in `used` sidechain slot are
different form the voting thresholds for activating a sidechain in an `unused`
sidechain slot. The voting thresholds are defined in the section specifying M2
- ACK Sidechain Proposal.

## Definition

This message MUST include two pieces of data:

1. Sidechain slot number
2. Sidechain description

A sidechain slot number is an unsigned integer.

The exact representation of this integer in the actual M1 message is defined in
the subsequent Encoding section.

A sidechain description is an array of bytes.

The exact representation of this array of bytes in the actual M1 message is defined in
the subsequent Encoding section.

## Encoding
The M1 script MUST be included in an output of a coinbase transaction. An M1
script that is not an output of a coinbases transaction MUST be ignored.

It MUST only be possible for those who can modify the coinbase transaction,
miners and mining pools most likely, to propose a sidechain. If a regular
Bitcoin user can propose a sidechain in non coinbase transaction - that is a
violation of BIP300 protocol rules.

The value of the output containing an M1 message MUST be ignored. It MAY be 0
BTC, it MAY be 100 BTC, as far as the BIP300 protocol is concerned it doesn't
matter. Miners and mining pools are free to dispose of their funds as they
please.

```C++
class CTxOut
{
public:
    CAmount nValue; // nValue MUST be ignored. 
    CScript scriptPubKey; // M1 MUST be encoded in scriptPubKey.
// ...
}
```

An M1 script MUST take the following form:

```
OP_RETURN [0xD5, 0xE0, 0xC4, 0xAF] <S> <D>
```

Bitcoin script interpreter fails immediately upon seeing an OP_RETURN, meaning
that the output is unspendable no matter what comes after OP_RETURN.

For the purposes of BIP300 protocol we shall reinterpret the bytes following
an OP_RETURN as just bytes, not as Bitcoins script opcodes.

So the bytes after an OP_RETURN MUST be interpreted just as bytes with absolutely
no semantic connection to Bitcoin script.

If a scriptPubKey is an OP_RETURN = `0x6A` followed by the four bytes `[0xD5, 0xE0,
0xC4, 0xAF]`, then it MUST be interpreted as an M1 message.

So the boolean expression
```
   scriptPubKey[0] == 0x6A // OP_RETURN
&& scriptPubKey[1] == 0xD5
&& scriptPubKey[2] == 0xE0
&& scriptPubKey[3] == 0xC4
&& scriptPubKey[4] == 0xAF
```
evaluating to true means that it is an M1 message.

`[0x6A, 0xD5, 0xE0, 0xC4, 0xAF]` is the header of M1.

The header is followed by the body.

The body of M1 consists of two sequential parts: `S` and `D`.

`S` is the number of the sidechain slot to be activated, if it is `unused`, or
to be overwritten, if it is `used`.

`D` is an array of bytes describing the sidechain that will either be activated
in an `unused` slot or that will overwrite the old sidechain that was occupying
a `used` slot.

`S` is a single byte it is always the byte at index 5. So in pseudocode:
```
S = scriptPubKey[5]
```

`D` is an array consisting of all the bytes following `S`, so all the bytes
from index 6 (including the byte at index 6)  until the end of the script. In
pseudocode:
```
D = scriptPubKey[6..]
```

Length of `D` is unspecified here. In practice it is limited by Bitcoin
validation rules.

## Conditions

M1 MUST be a Bitcoin script valid under existing validation rules, meaning that
no matter what sidechain slot is chosen and no matter what the bytes in the
array of the sidechain description - a coinbase transaction containing an
output with an M1 encoded in its scriptpubkey MUST be accepted by ANY currently
deployed Bitcoin node with a reasonable configuration - including nodes that do
enforce BIP300 rules and the ones that don't both.

An analogous condition applies to ALL subsequent messages - to M2, M3, M4, M5,
M6.

# M2. "ACK Proposal"
## Semantics
An M2 message SHALL be interpreted as an ordinary script if any of the
following conditions hold:

* The M2 message is not within a coinbase output.
* The M2 message is NOT _well-formed_, ie. NOT composed of exactly `38` bytes.
* The `32`-byte proposal identifier does not match the sha256d digest of any
  sidechain proposal created via an M1 message in a previous block.

Otherwise, an M2 message is considered _valid_. 

If another _valid_ M2 message for any sidechain slot is included within any 
coinbase output at a lower output index, the block is _invalid_ and MUST be 
_rejected_.
Otherwise, a node MUST increment the ACK counter for the sidechain proposal for which the sha256d digest is referenced by the `32`-byte proposal identifier.

If any of the following conditions hold, activation for the specified sidechain
proposal _fails_:

* The sidechain proposal refers to an unused slot, and the sidechain proposal
  age is greater than `UNUSED_SIDECHAIN_SLOT_PROPOSAL_MAX_AGE` blocks
* The sidechain proposal refers to an unused slot, the sidechain proposal age
  is greater than `UNUSED_SIDECHAIN_SLOT_ACTIVATION_MAX_FAILS` blocks, and the
  difference between the ACK counter for the proposal and the sidechain
  proposal age is not less than `UNUSED_SIDECHAIN_SLOT_ACTIVATION_MAX_FAILS`.
* The sidechain proposal refers to a used slot, and the sidechain proposal age
  is greater than `USED_SIDECHAIN_SLOT_PROPOSAL_MAX_AGE` blocks
* The sidechain proposal refers to an used slot, the sidechain proposal age is
  greater than `13501` blocks, and the difference between the ACK counter for
  the proposal and the sidechain proposal age is not less than `13501`.

  /// Where does this 13501 number come from?

If none of the conditions for failure are possible, the sidechain proposal
_succeeds_, and the sidechain described by the proposal is _activated_.

## Definition
## Encoding
M2 scripts are defined as scripts with the prefix `OP_RETURN [0xD6, 0xE1, 0xC5, 0xBF]`.
A _well-formed_ M2 script is defined as a script of the form
`OP_RETURN [0xD6, 0xE1, 0xC5, 0xBF] <S> <ACK>` where `S` is exactly 1 byte and
`ACK` is exactly `32` bytes.

`S` is sidechain slot number for which the sidechain described by `D` is
proposed.
`ACK` is the sha256d hash of the sidechain proposal description `D`.

## Conditions
# M3. "Propose Bundle"
## Semantics
An M3 message SHALL be interpreted as an ordinary script if any of the
following conditions hold:
* The M3 message is not within a coinbase output.
* The M3 message is NOT _well-formed_, ie. NOT composed of exactly `39` bytes.
* The `1`-byte sidechain slot number in the `M6ID` does not correspond to a sidechain slot
  that is _active_.

Otherwise, an M3 message is considered _valid_.
If any of the following conditions hold, the block is considered _invalid_ and
MUST be _rejected_:
* The `33`-byte `M6ID` has already been proposed in an M3
  message in a previous block, that has not been paid out.
* Another _valid_ M3 message with an identical sidechain slot number is
  included within any coinbase output at a lower output index.

If a _valid_ M3 message does not cause a block to be considered _invalid_, a
node MUST initialize an ACK counter and expiry block height corresponding to
the `33`-byte `M6ID`,
where the initial value of the ACK counter is `1`, and the initial value of the
expiry block height is the `WITHDRAWAL_BUNDLE_MAX_AGE - 1` greater than the
block height of the block that includes the M3 message.

## Definition
## Encoding
M3 scripts are defined as scripts with the prefix `OP_RETURN [0xD4, 0x5A, 0xA9,
0x43]`. A _well-formed_ M3 script is defined as a script of the form
```
OP_RETURN [0xD4, 0x5A, 0xA9, 0x43] <M6ID>
```
where `M6ID` is an array of exactly `33` bytes.

## Conditions
# M4. "Ack Bundle"
## Semantics

An M4 can have 4 different version.

`M4 = REPEAT_PREVIOUS_M4 | VOTES_ONE_BYTE | VOTES_TWO_BYTE | UPVOTE_LEADING_BY_50`.

The `REPEAT_PREVIOUS_M4` version of M4 MUST be interpreted as its name suggests
- execute the previously executed M4 again.

The `UPVOTE_LEADING_BY_50` version of M4 MUST be interpreted as its name
suggests. In pseudo code:
```
for each sidechain slot

    find an M6ID that leads other `M6ID`s in this slot by 50 votes

    if it does not exist
        abstain from voting in this sidechain slot
        (don't change vote counts for any M6ID in this slot)

    if it does exist
        upvote this M6ID
        (increment this M6ID's vote count by 1
        decrement the vote count of each other M6ID in this slot by 1)
```

The differences between the `VOTES_ONE_BYTE` version and the `VOTES_TWO_BYTE`
version are specified in the encoding section. Semantically they are exactly
the same.

An M4 of one of the two `VOTES_*` versions contains a list of sidechain slots
`S_0`, `S_1`, ..., `S_n`.

For every sidechain slot there is a vote `V_i = M6ID[1:..] | Abstain | Alarm`.

A vote `V_i` MUST be interpreted in the following way.

1. If it identifies an `M6ID`, then this `M6ID` MUST be upvoted (its vote count
   incremented by 1) and all other `M6ID`s in the sidechain slot `S_i` MUST be
   downvoted (vote count of each decremented by 1).
2. If it is an `Abstain` then the vote counts of all `M6ID`s in `S_i` MUST
   remain unchanged.
2. If it is an `Alarm` then the vote counts of all `M6ID`s in `S_i` MUST be
   downvoted (vote count of each decremented by 1).

The exact data structure to be used for storing `M6ID`s in active sidechain
slots is specified in the section on BIP300 State.

The block in which an `M6ID` has the number of votes greater than
`WITHDRAWAL_BUNDLE_INCLUSION_THRESHOLD` MUST include the corresponding `M6`, if
the block does not include the corresponding `M6` this block MUST be considered
invalid.

Corresponding here means that `m6_to_id(M6) = M6ID`, where `m6_to_id` is the
function defined in the section specifying `M6`.

## Definition
## Encoding

No more than ONE M4 MAY be included in an output of a coinbase transaction.

The `scriptPubKey` of this M4 output MUST have the following form:

```
OP_RETURN [0xD7, 0x7D, 0x17, 0x76] V Option<A>
```

Where `[0xD7, 0x7D, 0x17, 0x76]` is the M4 header identifying this script as an
M4, `V` is the byte that determines the version of the M4 encoded in the
script:
```
V == 0 -- REPEAT_PREVIOUS_M4
V == 1 -- VOTES_ONE_BYTE
V == 2 -- VOTES_TWO_BYTE
V == 3 -- UPVOTE_LEADING_BY_50
```

If `V == 0` or `V == 3`, meaning if it is the `REPEAT_PREVIOUS_M4` version or
the `UPVOTE_LEADING_BY_50` version, then nothing follows the `V` byte, so the script
MUST be exactly 6 bytes long.

If `V == 1` or `V == 2`, meaning if it is the `VOTES_ONE_BYTE` version or the
`VOTES_TWO_BYTE` version, then the `V` byte is followed by the array `A`, the
type of the elements of this array `A` is determined by the exact version.

For `VOTES_ONE_BYTE` we MUST interpret `A` as an array of 8 bit unsigned
integers, for `VOTES_TWO_BYTE` we MUST interpret `A` as an array of 16 bit
unsigned integers encoded in big endian byte order.

The index `i` of an element in array `A` determines the sidechain slot. Active
sidechain slot numbers MAY have gaps between them, so we can't use the index as
the actual sidechain slot number.

Instead we:
1. Take all the active sidechain slot numbers and put them in a vector `ASN`,
   for active slot numbers.
2. Sort the sidechain slot numbers in the vector in ascending order, so `[10,
   1, 19, 3]` after sorting would become `[1, 3, 10, 19]`. So now the `ASN`
   vector is sorted in ascending order.
3. Index the sorted `ASN` vector with `i`. For example if `ASN = [1, 3, 10,
   19]` and `i = 2`, then `ASN[i] == ASN[2] == 10`, so the element at index `i
   == 2` of `A` corresponds to sidechain slot 10.

If the `A.len() > ASN.len()`, then this M4 MUST be considered invalid, and the
whole block this M4 is included in MUST be considered invalid as well, because
we are attempting to set withdrawal bundle votes for sidechain slots that are
not active.

??? QUESTION: Does the above make sense? Would it be better to ignore the
excess votes in `A`?

The actual element `A[i]` is either an 8 bit or a 16 bit unsigned integer,
depending on the M4 version.

For the `VOTES_ONE_BYTE` version of M4 an element of `A` at index `i`, which is
an 8 bit unsigned integer, MUST be interpreted in the following way:

Value `A[i] == 254 // 0xFE` means `ALARM`, and it MUST be interpreted as defined
in the semantics section above.

Value `A[i] == 255 // 0xFF` means `ABSTAIN`, and it MUST be interpreted as
defined in the semantics section above.

For values of `A[i]` from `0` to `253` inclusively it uniquely identifies one
`M6ID` out of potentially many `M6ID`s which were previously proposed by `M3`s
for the sidechain slot determined by index `i` (see the algorithm above to see
    how to get the sidechain slot number from `i`).

This value of `A[i]` MUST be mapped to the actual `M6ID` in sidechain slot
determined by `i` in the following way:

1. Take all `M6ID`s currently in this sidechain slot, and put them in a vector.
2. Sort all these `M6ID`s chronologically in ascending order by the block
   number of the block they were included in. The oldest (the one with the
   lowest inclusion block number) `M6ID` would have the index `0` in this
   vector, second oldest would have index `1`, etc.
3. It is possible for two `M3`s proposing two different `M6ID`s for the same
   sidechain slot to be included in the same block, so it is possible for two
   different `M6ID`s to have the same inclusion block number. In these cases
   their order in the sorted vector MUST be the same as their order in the
   coinbase `vout` vector. Let us call this chronologically sorted vector
   `M6IDS_chronological`.
4. Get the actual `M6ID` value by indexing the sorted vector `M6ID =
   M6IDS_chronological[A[i]]`. Then we MUST upvote this `M6ID` as defined in
   the semantics section above. If there is no `M6ID` in the
   `M6IDS_chronological` at index `A[i]` (index out of range error), then this
   M4 along with the block it is included in MUST be considered invalid.

   ??? QUESTION: Would it make more sense to ignore the M4 with the index out
   of range error?

For the `VOTES_TWO_BYTE` version of M4 an element of `A` at index `i`, which is
a 16 bit unsigned integer encoded in big endian byte order, MUST be interpreted
in the following way:

Value `A[i] == 65534 // 0xFFFE` means `ALARM`, and it MUST be interpreted as defined
in the semantics section above.

Value `A[i] == 65535 // 0xFFFF` means `ABSTAIN`, and it MUST be interpreted as
defined in the semantics section above.

For values of `A[i]` from `0` to `65533` inclusively it uniquely identifies one
`M6ID` out of potentially many `M6ID`s which were previously proposed by `M3`s
for the sidechain slot determined by index `i` (see the algorithm above to see
    how to get the sidechain slot number from `i`).

The procedure for getting the actual `M6ID` from the element `A[i]` is exactly
the same as the one defined above for the `VOTES_ONE_BYTE` version. The only
difference is that with the `VOTES_TWO_BYTES` version of M4 it is possible to
refer to `M6ID` at indicies greater than `253` in the `M6IDS_chronological`
vector.

If an `M4` has the version `VOTES_TWO_BYTES` and there are no elements in its
`A` array which are greater than `253`, then this `M4` along with the block it
is included in MUST be considered invalid, because it is wasting bytes by using
the 16 bit version when the 8 bit version would suffice.

??? QUESTION: Does it make sense to enforce this rule?

## Conditions
# M5. "Deposit"

## Semantics
An M5 with sidechain slot number S, value V, and address A means:

I, a Bitcoin user with sufficient funds, deposit V sats to address A to the
sidechain in slot S. These V sats will no longer be available on the mainchain,
unless withdrawn using M6.

A treasury UTXO for slot S is a single UTXO in the Bitcoin UTXO set that holds
all funds currently in circulation on the sidechain in slot S.

An M5 is a Bitcoin transaction.

M5 for sidechain slot S MUST either create the first treasury UTXO for
sidechain slot S or, if it already exists, spend the treasury UTXO for
sidechain slot S and then create a new one.

There MUST never be two treasury UTXOs for the same sidechain slot.

## Definition
## Encoding

M5 MUST be a valid Bitcoin transaction.

M5 MUST have the following three parts:

1. treasury UTXO
2. address OP_RETURN output
3. input spending previous treasury UTXO (if it is not the first ever deposit
   to this sidechain)

Let us consider these three parts in turn.

### Treasury UTXO

Under BIP300 rules `OP_NOP5` is known as `OP_DRIVECHAIN`.

A treasury UTXO MUST have a `scriptPubKey` of the following form:

```
OP_DRIVECHAIN OP_PUSHBYTES_1 <S> OP_TRUE
```

S is a 1 byte sidechain slot number.

The nValue of a treasury UTXO for sidechain slot S MUST be equal to the total
amount of funds circulating in the sidechain active in sidechain slot S at all
times.

Let `n` be the sequence number of the deposit. The first ever deposit in a
sidechain will have sequence number `n = 0`, second one will have sequence
number `n = 1`, and so on.

So, in order to make a deposit of `V_n` sats to a sidechain we MUST first know
the current total amount of sats locked in the treasury UTXO we are spending,
let us call it `T_n` for total.

We can get `T_n` by looking up the `nValue` field of the treasury UTXO we are
spending in this M5 transaction. If we are making the first ever deposit, and
the treasury UTXO doesn't exist, we set `T_0 = 0`.

Then we MUST set the new total amount of sats locked in the newly created
treasury UTXO, let us call it `T_n+1` so `T_n+1 = T_n + V_n`.

```C++
class CTxOut
{
public:
    CAmount nValue; // T_n+1 = T_n + V
                    // where
                    // T_n+1 is new total,
                    // T_n is previous total,
                    // V is deposit value.
    CScript scriptPubKey; // MUST be a proper OP_DRIVECHAIN script.
// ...
}
```

An individual treasury UTXO by itself (with the exception of the first ever
deposit) does not supply enough data in order to recover the actual deposit
value `V_n`.

In order to recover `V_n = T_n+1 - T_n` we MUST know both `T_n+1` and `T_n`.

`T_n+1` is the `nValue` of the treasury UTXO created in the M5 transaction
encoding the `n`th deposit.

`T_n` is the `nValue` of the treasury UTXO spent in the M5 transaction encoding
the `n`th deposit.

### address OP_RETURN output

`nValue` of the address OP_RETURN output MUST be ignored, Bitcoin users are
free to dispose of their funds as they please.

An address OP_RETURN output MUST have a `scriptPubKey` of the following form

```
OP_RETURN <A>
```

Where `A` is an array of bytes encoding the sidechain address for the deposit.
Interpretation of `A` for a particular sidechain slot is up to the authors of the
sidechain active in that slot.

`A` MUST be interpreted by the BIP300 enforcer software as an arbitrary
meaningless array of bytes.

```C++
class CTxOut
{
public:
    CAmount nValue; // MUST be ignored.
    CScript scriptPubKey; // OP_RETURN <A>
// ...
}
```

An address OP_RETURN output MUST come immediately after the treasury UTXO in
the `vout` vector of the M5 transaction.

```C++
class CTransaction
{
    // ...
    const std::vector<CTxIn> vin;
    const std::vector<CTxOut> vout;
    // ...
}
```

So if a treasury UTXO is at the index 5 in the `vout` vector in the M5
transaction, then the corresponding address OP_RETURN output MUST be at the
index 6.

In pseudocode the following boolean expression MUST be true for any valid M5:
```
   vout[i] == OP_DRIVECHAIN OP_PUSHBYTES_1 <S> OP_TRUE
&& vout[i+1] == OP_RETURN <A>
```

If an M5 transaction has a UTXO treasury output and no address OP_RETURN
output, then it MUST be considered invalid by the BIP300 enforcer software.

### input spending previous UTXO treasury output

An M5 transaction MUST include an input spending the previous UTXO treasury
output in its `vin` vector. If it does not, it MUST be considered invalid.

The sidechain slot number `S` encoded in the previous treasury UTXO, which is
spent in this input of this M5 transaction MUST match the sidechain slot number
`S'` encoded in the new treasury UTXO created by this M5 transaction.

### Recovering the `n`th deposit from the M5 messages

An `n`th deposit for sidechain slot `S` has three parts:

1. `S` - the sidechain slot number.
2. `V_n` - the value to be deposited in sats.
3. `A_n` - the sidechain address for the deposit.

In order to recover a deposit in a form usable by sidechain software we must
know all three.

The deposit with `n = 0` is special, because we can get all three parts from a
single Bitcoin transaction: `M5_0` - the first ever deposit to be made in this
slot.

This `M5_0` transaction has two special outputs in its `vout` vector.

```C++
class CTransaction
{
    // ...
    const std::vector<CTxIn> vin; // Nothing here.
    const std::vector<CTxOut> vout; // Two outputs with all three parts.
    // ...
}
```

The first output is the first treasury UTXO.

```C++
class CTxOut
{
public:
    CAmount nValue; // Equal to T_1.
    CScript scriptPubKey; // Sidechain slot number S is encoded here.
// ...
}
```

Its `nValue` is equal to `T_1`, and because `V_0 = T_1 - T_0` and `T_0 = 0` we
know that `V_0 = T_1`.

Its `scriptPubKey` encodes the sidechain slot number `S` with the
`OP_DRIVECHAIN` script:

```
OP_DRIVECHAIN OP_PUSHBYTES_1 <S> OP_TRUE
```

Now we know `V_0` and `S`.

Immediately at the index in the `vout` vector after the treasury UTXO comes the
address OP_RETURN output.

```C++
class CTxOut
{
public:
    CAmount nValue; // MUST be ignored.
    CScript scriptPubKey; // OP_RETURN <A_0>
// ...
}
```

We know `S`, `T_1`, and `A_0`.
We can compute `V_0 = T_1 - T_0 = T_1 - 0 = T_1`.
Now we know all three parts we need `S`, `V_0`, and `A_0`.

So we have recovered the `n = 0` deposit made to the sidechain slot `S`.

A deposit with `n > 0` is different, in order to recover it we shall need two
Bitcoin transactions `M5_n` and `M5_n-1`.

We can get `S`, `A_n`, and `T_n+1` from `M5_n`.
We can get `T_n` from `M5_n-1`.
Then we can get `V_n = T_n+1 - T_n`.

So each deposit with `n > 0` is encoded by a pair of Bitcoin transactions.

```
      M5_0 -- n = 0
M5_0, M5_1 -- n = 1
M5_1, M5_2 -- n = 2
M5_2, M5_3 -- n = 3
M5_3, M5_4 -- n = 4
...
```

///
TODO: Specify how M6 withdrawal bundles, which have `T_n < T_n-1`, are to be
handled. Do we skip them, so the deposit sequence numbers remain continuous, or
do we count them, so there are gaps in the deposit sequence numbers?

I think it makes more sense to count them, so we know at which sequence number
a withdrawal happened.

If we attempt to look up a deposit at a withdrawal sequence number, the BIP300
enforcer deposits database would just say "a withdrawal happened at this
sequence number".

It would also make sense to store mainchain block height, at which M5 or M6 was
included, alongside the corresponding sequence number in the BIP300 enforcer
database.
///

It is also important to keep track of `n` - the deposit sequence number, so in
the end we have four parts `n`, `S`, `V_n`, `A_n`.

It would make sense for the BIP300 enforcer software to keep a database
containing `n`, `S`, `V_n`, and `A_n` for all deposits across all active
sidechain slots, because otherwise we would have to rescan the whole Bitcoin
blockchain every time we need to look up a deposit.

It would also make sense for the BIP300 enforcer software to keep track of last
`T_n` for every sidechain slot `S`, so whenever it receives `M5_n` encoding
`S`, `T_n+1`, and `A_n` it can compute `V_n = T_n+1 - T_n` and thus get all
four parts `n`, `S`, `V_n`, and `A_n` it needs in order to update its deposits
database.

### Conclusion

An M5 transaction MUST include two outputs: a treasury UTXO output and an
address OP_RETURN output. The address OP_RETURN output MUST be placed right
after the treasury UTXO output in the M5 transaction's `vout` vector.

If a treasury UTXO for this sidechain slot does not exist, then an M5
transaction MUST NOT include an input spending the previous treasury UTXO (as
it doesn't exist).

The `nValue` of this phantom non-existent treasury UTXO MUST be set to 0, so
when a sidechain is first activated in a slot it has exactly 0 sats in
circulation.

If a treasury UTXO for this sidechain slot does exist, then an M5 transaction
MUST include one input spending the previous treasury UTXO.

The `nValue` of the actual previous treasury UTXO must be looked up in order to
get the total amount of sats in circulation for the sidechain active in the
slot.

The `nValue` of the newly created treasury UTXO MUST be greater than the
`nValue` of the spent treasury UTXO, so when we deposit funds to a sidechain,
we increase the amount of funds in circulation for that sidechain.

??? QUESTION: What happens to the treasury UTXO when a `used` sidechain slot is
overwritten with a different sidechain?

Does the same chain of treasury UTXOs continue?

## Conditions
# M6. "Withdrawal Bundle"
## Semantics
An M6 is an aggregate of withdrawals 

```
[(Bitcoin address, value)]
```

Where `S` is the sidechain slot number and `C` is the withdrawals commitment.
## Definition
## Encoding
An M6 MUST be a valid Bitcoin transaction.

An M6 MUST have only one input. This one input MUST spend the treasury UTXO for
the sidechain from which the withdrawal is made.

An M6 MUST have an output with the new treasury UTXO.

The newly created treasury UTXO MUST be the first element in the `vout`
vector of the M6 transaction.

The sidechain slot number `S` encoded in the new treasury UTXO MUST match the
sidechain slot number `S` encoded in the spent treasury UTXO.

```C++
class CTxOut
{
public:
    CAmount nValue; // MUST be T_n = T_n-1 - P_total - F_total.
    CScript scriptPubKey; // OP_DRIVECHAIN OP_PUSHBYTES_1 <S> OP_TRUE
// ...
}
```

Where `T_n` is the `nValue` for the treasury UTXO created in this M6, `T_n-1`
is the `nValue` of treasury UTXO spent by this M6, `P_total` is the total
amount paid out in this withdrawal bundle, and `F_total` is the total amount of
fees paid to the miners in this withdrawal bundle.

Withdrawal outputs in the M6 withdrawal bundle transaction's `vout` vector MUST NOT be placed before the treasury output.

```C++
class CTransaction
{
    // ...
    const std::vector<CTxIn> vin; // MUST have exactly one input spending
                                  // previous treasury UTXO.

    const std::vector<CTxOut> vout; // The new treasury UTXO MUST be the first output.
                                    // The preceding outputs are the actual
                                    // withdrawal pay out outputs.
    // ...
}
```

The amount of funds locked in the newly created treasury UTXO MUST be less than
the amount of funds locked in the spent treasury UTXO by exactly `P_total +
F_total`.

### The `m6_to_id` function definition

The `m6_to_id` function MUST be pure, meaning it MUST have no side effects.

The `m6_to_id` function takes two arguments: a valid `M6` Bitcoin transaction
and `T_n-1`, the value locked in the treasury UTXO spent in this `M6`.

The `m6_to_id` returns either `None` if any of its arguments are invalid or
`Some(M6ID)`, where `M6ID` is a `33` byte array.

The `txid` of an `M6` cannot be used as the `M6ID`, because when
an `M6` withdrawal bundle is proposed with an `M3`, the treasury UTXO,
which must be spent by the `M6` when its `M6ID` reaches
`WITHDRAWAL_BUNDLE_INCLUSION_THRESHOLD + 1` votes (per `M4` specification),
most likely does not yet exist.

Therefore, the `M6ID` is derived from a modified `M6`, `M6_blinded`.

`M6_blinded` differs from an `M6` in two ways:

1. The `vin` vector of `M6_blinded` MUST be empty, whereas the `vin` of `M6`
   includes the treasury UTXO, current at the block when this `M6` must be
   included (this is specified in the section on `M4`).
2. The last element in the `vout` vector of `M6_blinded` MUST be an output with
   `nValue = 0` and `scriptPubKey = OP_RETURN F_total_be_bytes`, where
   `F_total_be_bytes` is the 64 bit unsigned integer `F_total` (total amount of
   fess paid to the miners by this M6) encoded as an array of 8 bytes in big
   endian order. This `OP_RETURN` output replaces the treasury UTXO.

So the `M6ID` is computed in five steps:

1. Remove the treasury UTXO input.
2. Remove the treasury UTXO output.
3. Add the `OP_RETURN` script with `F_total`.
4. Compute the `txid` of the resulting `M6_blinded` transaction
5. Prepend the sidechain slot number.
   The resulting `33`-byte array is the `M6ID`.

In more detail:

`M6ID` MUST be computed by `m6_to_id` using the following steps:

1. Remove the single input spending the previous treasury UTXO from the `vin`
   vector, so that the `vin` vector is empty.
2. Remove the new treasury UTXO from the `vout` vector, which is always the
   first output.
2. Compute `P_total` by summing the `nValue`s of all pay out outputs in this
   `M6`, so `P_total` = sum of `nValue`s of all outputs of this `M6` except for
   the new treasury UTXO at index 0.
3. Set `T_n` equal to the `nValue` of the treasury UTXO created in this `M6`.
4. Compute `F_total = T_n-1 - T_n - P_total`, since we know that `T_n = T_n-1 -
   P_total - F_total`, `T_n-1` was passed as an argument, and `T_n` and
   `P_total` were computed in previous steps..
5. Encode `F_total` as `F_total_be_bytes`, an array of 8 bytes encoding the 64
   bit unsigned integer in big endian order.
6. Push an output to the front of `vout` of this `M6` with the `nValue = 0` and
   `scriptPubKey = OP_RETURN F_total_be_bytes`.

```C++
class CTxOut
{
public:
    CAmount nValue; // MUST equal 0.
    CScript scriptPubKey; // OP_RETURN F_total_be_bytes
// ...
}
```
At this point we have constructed `M6_blinded`.

8. Compute `M6ID = S : txid(M6_blinded)`,
   where `S` is the sidechain slot number.

## Conditions

# BIP300 State specification

## Sidechain Proposals

`data_hash_to_sidechain_proposal: ACK -> SidechainProposal`

where `SidechainProposal` is defined as:

```rust
pub struct SidechainProposal {
    pub sidechain_number: u8,
    pub data: Vec<u8>,
    pub vote_count: u16,
    pub proposal_height: u32,
}
```

and where `ACK` is the `sha256d` hash of the `data` field of `SidechainProposal`.

## Active Sidechains

`sidechain_number_to_sidechain: S -> Sidechain`

where `S` is the sidechain slot number, and where `Sidechain` is defined as:

```rust
pub struct Sidechain {
    pub sidechain_number: u8,
    pub data: Vec<u8>,
    pub vote_count: u16,
    pub proposal_height: u32,
    pub activation_height: u32,
}
```

## Deposits

(S, n) -> Deposit(block_height, V_n, T_n, A_n) | Withdrawal

Where `S` is the sidechain slot number, `n` is the deposit sequence number,
`block_height` is the Bitcoin block height, `V_n` is the value of the deposit,
`T_n` is the total amount of funds that was locked in the treasury UTXO before
`V_n` more was added by this deposit, `A_n` is the deposit destination
sidechain address.

## M6IDs

`sidechain_number_to_pending_m6ids: S -> Vec<PendingM6id>`

Where `S` is the sidechain slot number, and where `PendingM6id` is defined as

```rust
pub struct PendingM6id {
    pub m6id: Hash256,
    pub vote_count: u16,
}
```

# Validation Rules specification
## Transaction Validation Rules specification

These rules only apply to non coinbase transactions.

A non coinbase transaction is either a regular Bitcoin transaction, an `M5`, or
an `M6`.

Messages `M1`, `M2`, `M3`, `M4` never appear in non coinbase transactions, if
an OP_RETURN matching `M1`, or `M2`, `M3`, or `M4` appears in a non coinbase
transaction, then MUST be ignored by the BIP300 enforcer.

If a transaction spends a treasury UTXO as one of its inputs and does not
create a new treasury UTXO as one of its outputs, that transaction MUST be
considered invalid.

### M5

If the treasury UTXO for sidechain slot `S` exists and a transaction creates a
new treasury UTXO for `S` without spending the already existing treasury UTXO,
then this transaction MUST be considered invalid.

But if the treasury UTXO for sidechain slot `S` doesn't exist, meaning there
were no deposits to this sidechain slot since its activation, and a transaction
creates a new trasury UTXO for `S`, then it is a valid `M5` deposit, if it
includes the address OP_RETURN.

If a transaction spends a treasury UTXO with value `T_n` and creates a new
treasury UTXO with value `T_n+1 > T_n`, then it MUST be considered invalid
unless it contains the address OP_RETURN output immediately after the new
treasury UTXO, per specification of `M5`.

/// Should we enforce the inclusion of the address OP_RETURN here? ///

### M6

If a transaction spends a treasury UTXO with value `T_n` as one of its inputs
and the new treasury UTXO it created has value `T_n+1 < T_n`, then so it MUST
be considered invalid unless:

1. It is a valid `M6` according to the `M6` specification above.
2. Its `M6ID` computed using the `m6_to_id` function, defined above, matches an
   `M6ID` in the BIP300 state that has reached enough votes to be included,
   meaning that its `vote_count > WITHDRAWAL_BUNDLE_INCLUSION_THRESHOLD`
   and `age <= WITHDRAWAL_BUNDLE_MAX_AGE`, where `age = current_block_height -
   proposal_block_height`.

## Block Validation Rules specification

All non coinbase transactions in the block MUST be valid according to
transaction validation rules defined above, if any one of them is invalid, then
the whole block is invalid.

The coinbase transaction never contains a treasury UTXO, if there is an output
matching the treasury UTXO script, then it MUST be interpreted by the BIP300
enforcer as just another meaningless output.

When validating a block the BIP300 enforcer MUST iterate through all outputs in
this block's coinbase transaction and check that the following validation rules
for `M1`, `M2`, `M3`, `M4` are not violated.

### M1
A block MUST never be considered invalid because of an `M1`.

There MAY be duplicate `M1`s with exactly the same `S` and `D` in the same
coinbase transaction.

There MAY be multiple `M1`s with exactly the same `S` and different values of
`D`.

There MAY be multiple `M1`s with different values of `S` and exactly the same
`D`.

### M2
If there are two or more `M2`s upvoting the exact same sidechain proposal `(S,
ACK)`, then this block MUST be considered invalid.

/// Maybe it would make more sense to ignore the duplicate upvote? ///

### M3
If an `M3` proposes an `M6ID` for sidechain slot `S` that is inactive, then
this block MUST be considered invalid.

/// Maybe it would make more sense to ignore proposals for inactive slots? ///

There MAY be duplicate `M3`s with exactly the same `S` and `M6ID` in the same
coinbase transaction.

There MAY be multiple `M3`s with exactly the same `S` and different values of
`M6ID`.

There MAY be multiple `M3`s with different values of `S` and exactly the same
`M6ID`.

### M4

If an `M4` of version `VOTES_ONE_BYTE` or `VOTES_TWO_BYTE` sets a vote in an
inactive sidechain slots, then the block MUST be considered invalid.

If an `M4` of version `VOTES_ONE_BYTE` or `VOTES_TWO_BYTE` sets a vote in an
active sidechain slot for an `M6ID` that doesn't exist, then the block MUST be
considered invalid.

# BIP300 State update rules
## Connect Block specification

### M1

We received an `M1` with `S` and `D`.

When we receive an `M1` we MUST store a `SidechainProposal` in the
`data_hash_to_sidechain_proposal` database:

```rust
pub struct SidechainProposal {
    pub sidechain_number: u8,
    pub data: Vec<u8>,
    pub vote_count: u16,
    pub proposal_height: u32,
}
```

- `sidechain_number` MUST be set to `S`.
- `data` MUST be set to `D`.
- `vote_count` MUST be set to 0.
- `proposal_height` MUST be set to the block height of the block in which the `M1` was received.

Important:

If a sidechain proposal with exactly the same `S` and `D` already exists in the
database, then this `M1` MUST be ignored. Otherwise miners can reset the vote
count on any sidechain proposal at will.

This is implemented in the `Bip300::handle_m1_propose_sidechain` method in the
reference implementation.

### M2

We received an M2 with `S` and `ACK`. Note that `ACK` is equal to the sha256d hash of `D`.

If a sidechain proposal referred to by `ACK` doesn't exist in the database,
then this M2 MUST be ignored.

We MUST get the sidechain proposal stored at key `ACK` from the database:

```rust
pub struct SidechainProposal {
    pub sidechain_number: u8,
    pub data: Vec<u8>,
    pub vote_count: u16,
    pub proposal_height: u32,
}
```

If the sidechain number `S` doesn't match `sidechain_number` in the proposal we
got from the database, then this M2 MUST be ignored.

If the two above conditions for ignoring an M2 are not met, then we MUST
increment the `vote_count` of the proposal and put this updated proposal back
in the database.

After the `vote_count` was incremented we MUST check whether or not a new
sidechain was activated as a result of processing this M2. We do this in the
following way:

We define `sidechain_proposal_age = height -
sidechain_proposal.proposal_height`, where `height` is current block height.

We set `sidechain_slot_is_used` to `true` if a sidechain exist in the
`sidechain_number_to_sidechain` database at key `S`, otherwise we set it to
`false`.

Then we define `new_sidechain_activated` as:

```rust
let new_sidechain_activated = {
    sidechain_slot_is_used
        && sidechain_proposal.vote_count > USED_SIDECHAIN_SLOT_ACTIVATION_THRESHOLD
        && sidechain_proposal_age <= USED_SIDECHAIN_SLOT_PROPOSAL_MAX_AGE as u32
} || {
    !sidechain_slot_is_used
        && sidechain_proposal.vote_count > UNUSED_SIDECHAIN_SLOT_ACTIVATION_THRESHOLD
        && sidechain_proposal_age <= UNUSED_SIDECHAIN_SLOT_PROPOSAL_MAX_AGE as u32
};
```

If `new_sidechain_activated` is `true`, then:

We MUST delete the `SidechainProposal` stored at key `ACK` in the
`data_hash_to_sidechain_proposal` database.

Then we MUST put a `Sidechain` defined as

```rust
pub struct Sidechain {
    pub sidechain_number: u8,
    pub data: Vec<u8>,
    pub vote_count: u16,
    pub proposal_height: u32,
    pub activation_height: u32,
}
```

into the `sidechain_number_to_sidechain` database at key `S`.

- `sidechain_number` MUST be set to `S`.
- `data` MUST be set to `data` of `SidechainProposal` that was activated.
- `vote_count` MUST be set to current `vote_count` of `SidechainProposal` that was activated.
- `proposal_height` MUST be set to `proposal_height` of `SidechainProposal` that was activated.
- `activation_height` MUST be set to the block height of the block in which this `M2` was included.

So, in summary:

A `SidechainProposal` is promoted from being just a proposal to being an actual
active `Sidechain`. We do this by removing the promoted `SidechainProposal`
from the `data_hash_to_sidechain_proposal` database, and by adding the newly
activated `Sidechain` to the `sidechain_number_to_sidechain` database.

All of this is implemented in the `Bip300::handle_m2_ack_sidechain` method in
the reference implementation.

### M3
### M4

### M5
### M6

## Disconnect Block specification

Whenever a Bitcoin block is disconnected the BIP300 State MUST be updated in
the following way ... .

# Testing Strategy
## Unit Testing
## Property Testing
## Fuzzing
## Benchmarking
